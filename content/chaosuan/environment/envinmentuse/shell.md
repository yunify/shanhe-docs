---
title: "shell"
description: Test description
draft: false
enableToc: false
keyword: test
weight: 4
---

#### 一、正则表达式

```bash
# 通配符
任意长度任意字符,属于通配符
? 单个任意字符,属于通配符
# 基础正则表达式
\	转义符
^	匹配行首
$	匹配行尾
^$	表示空行
.	匹配除换行符\n之外的任意单个字符
.*	匹配任意长度任意字符
[]	匹配包含在[字符]之中的任意一个字符
[^]	匹配[^字符]之 外的任意一个字符
^[^字符]	匹配非 指定字符开头的行
\{n\}	匹配之前的项n次，n是可以为0的正整数
\{n,\}	之前的项至少需要匹配n次
\{n,m\}	指定之前的项至少匹配n次，最多匹配m次
# 转义符
\a	响铃
\b	退格
\n	换行
\r	替换字符
\t	空一个tab键位置
\v	制表符
\\\	代表一个反斜杠字符
```

#### 二、脚本'三剑客'

``` bash
# grep
$ grep 参数 '关键字' 文件名
参数
	-i	忽略大小写
	-v	显示没有被模式匹配到的行,相当于^[^]
	-o	只显示被模式匹配到的字符串
	-n	显示匹配行及行号
	-c	只输出匹配行的计数
	-l	查询多文件时只输出包含匹配字符的文件名
	-L	打印不匹配的文件名
	-e	满足多个过滤参数的条件
	-r	递归查询
	-E	使用扩展的正则表达式
	-w	只显示全单词符合的行
	-q	匹配内容不显示(静默模式)
$ sed 选项 '行定界 /old字符/new字符/ 列定界符 处理动作' 文件名
定界符
	s 替换指定的字符
	g 全局替换
	i 不区分字符大小写
选项
	-i 直接编辑原文件
	-e 'script' -e 'script': 指定多个编辑指令
	-n 静默模式(默认打印)，或只显示匹配后的内容
处理动作:
	! 取反，如!W、!=、!d、!i\#、!r \#、!w \#
	d 删除
	c 取代,c后面可以接字串，这些字串可以取代n1,n2之间的行
	p 打印，通常p会与参数-n- -起
	i或i\ : 在被指定到行的上面插入文本
	a或a \ : 在被指定的行的下面插入文本
	\n: 换行
	r 文件:在指定位置把另外-个文件的内容插入
	w 文件:将符合条件的所有行保存至指定文件中
	= 显示符合条件的行的行号
$ awk 选项 '模式或条件(编辑命令)' 文件
# awk的常用的内置变量
	FILENAME awk 读取的文件名
	FNR 浏览文件的记录数(浏览文件次数，文件会累加记录)
	NF 浏览记录的域个数(当前行的字段数)
	$NF 表示最后一个区域
	NR 已读的记录行数(命令后跟的所有文件统一合并计数)
```

#### 三、例子

```bash
# grep
grep -i '关键字' 文本名称  # 忽略大小写过滤关键字
grep -v '关键字' 文本名称	# 过滤非关键字的行
grep -o '关键字' 文本名称	# 只显示被匹配到的字符
grep -n '关键字' 文本名称	# 过滤关键字，并带行号打印
grep -e '关键字1' -e '关键字2' 文本名称 # 过滤关键字1并且过滤关键字2
grep -l '关键字' 文本名称1  文本名称2	# 过滤关键字存在的文件名
grep -L '关键字' 文本名称1	 文本名称2	# 过滤关键字不存在的文件名
grep -w '关键字' 文本名称	# 以单词形式过滤
grep -q '关键字' 文本名称	# 静默模式，不输出任何信息
grep '关键字' 文本名称	 	# 过滤带有关键字的行
grep '^关键字' 文本名称	# 过滤以关键字开头的行
grep '关键字$' 文本名称	# 过滤以关键字结尾的行
grep '^a..b' 文本名称	  # 过滤以a开头中间两个任意字符b结尾的行
grep 'a*' 文本名称		  # 过滤以a开头后面跟着任意长度的任意字符的行
grep -c '^$' 文本名称	  # 过滤空行
# sed
sed 's/aaa/bbb/' 文本名称   # 全文首匹配替换
sed 's/aaa/bbb/g' 文本名称  # 全文匹配替换	
sed 's/aaa//g' 文本名称		# 全文匹配替换为空
sed '2 s/aaa/bbb/' 文本名称 # 第二行单行首匹配替换
sed '2 s/aaa/bbb/g' 文本名称# 第二行单行全行替换
sed 's/^/aaa/g' 文本名称	# 全行首插入
sed 's/aaa/bbb/2' 文本名称	# 每行第二次匹配到的替换
sed '2 s/aaa/bbb/2' 文本名称# 第二行第二次匹配到的替换
sed 'G' 文本名称			# 在文件的每行后添加空行
sed '1c aaa' 文本名称		# 整行低缓，把第一行替换成aaa
sed '1,3c aaa' 文本名称		# 把第一行到第三行替换成一行aaa
sed -n '2p' 文本名称		# 只显示第二行
sed -n '1,2p' 文本名称		# 只显示第一行到第二行
sed '2q' 文本名称			# 只打印前两行
sed -n '/ftp/p' 文本名称	# 只打印带有ftp字符的行
sed -n '$p' 文本名称		# 只打印最后一行
sed -n '2,$p' 文本名称		# 只打印第二行到最后一行
sed -n '1p;$p' 文本名称		# 只打印第一行到最后一行
sed '2d' 文本名称			# 删除第二行
sed '$d' 文本名称			# 删除最后一行
sed '1,3d' 文本名称			# 删除第一行到第三行
sed '/^\$/d' 文本名称		# 删除以$字符开头的行
sed '$!d' 文本名称			# 删除除了最后一行外的其他行
sed '/^$/d' 文本名称		# 删除空行
sed '/aaa$/d' 文本名称		# 删除以aaa结尾的行
# awk
awk 'NR==1{print}' 文本名称              # 打印文件第一行
awk -F ':' '{print $1}' 文本名称 		 # 以:为分隔符，只打印整个文件第一列
awk -F':’ {print $3}' 文本名称 	   		# 以:为分隔符，只打印文件第三列
awk '{print}' 文本名称			 	    # 以默认分隔符(空格分割符)，打印整个文件($0表示整个文件列)
awk '{print}' < 文本名称
cat 文本名称 |awk '{print}'
awk '{print $0}' 文本名称
awk '/root/' 文本名称                   # 以:号为分割符，匹配打印带有root字符的行(/字符/字符匹配)
awk -F':' '/^root/' 文本名称            # 以:号为分割符，打印开头是root字符的行
awk -F':' '/^\<root\>/' 文本名称          
awk -F':' '/^(root|ftp)/{print $1,$7}' 文本名称 # 以:号为分割符，打印开头是root字符或者ftp字符的行的第一列和第七列字符
awk -F':' '!/^root/' 文本名称            # 以:号为分割符,打印开头非root字符的行,!取反的意思
awk '/^$/' 文本名称                      # 打印文件中空行
awk '/2019$/' 文本名称                	 # 以:空格为分隔符，打印结尾为2019的行
awk '/^[Rr]oot/' 文本名称 				 # 以默认空格分割符，打印Root或root开头的行
ifconfig ens32|awk '/<inet\>/{print $2}'# 过滤网卡IP
# 条件操作描述符
	关系操作符>、 >=、<、 <=、==(精确匹配)、!=(不等于)
	赋值操作符=、+=、*=、/=、%=、^=
# 条件表达操作符
	或||、与&&、非!
	匹配操作符-(模式匹配,模糊匹配) !~
	算术操作符+、-、*、/、%、^(次方)
```

#### 四、shell 条件测试

```bash
# 条件测试
	#测试特定的条件是否成立当条件成立则返回0，否则返回其他数值根据命令的执行返回值来判断
	0  真 执行成功True
	非0 假 执行失败False
# test命令测试形式
	test 条件表达式
# 常见的条件测试
文件测试
	-d 判断是否为目录
	-f 判断是否为文件
	-r 判断当前用户是否有读取权限
	-W 判断当前用户是否有写入权限
	-x 判断当前文件是否有执行权限
	-e/a 判断目录或文件是否存在
# 例子	
	test -d /etc/passwd
	echo $?
	[ -d /etc/ ]
	echo $?
	[ -f /opt/abc.txt ] || touch /opt/abc.txt
	echo $?返回值为0表示命令正确,否则失败
# 整数比较
	给定两个整数,判断第一个数是否大于,小于,等于第二个数
	-eq 表示等于
	-ne 表示不等于
	-gt 表示大于
	-lt 表示小于
	-le 表示小于等于，满足其中任意一个条件即为真
	-ge 表示大于等于,满足其中任意-个条件即为真
# 字符串比较
	检查用户输入的字符串是否符合需求
	== 表示第一个字符串和第二个字符串相同
	!= 第一个字符串和第二个字符中不同(!取反的意思)
	-z 字符串:字符串是否为空，不空则假，空则为真
	[-n字符串]]: 字符串是否为空，不空则真，空则为假
# 例子	
	abc=www
	[ -Z $abc ] && echo "$abc"
	[[ -n $www ]lecho $?
	a=root
	b=ftp
	["$a" == "$b" ]:echo $?
	["$a"!= "$b" ]:echo $?
	a="root"
	b="root"
	["$a" == "$b" ]:echo $?
# 多个条件的逻辑测试
	测试两个或多个条件之间的依赖关系
	&&/-a 逻辑与:并且的意思,两边的条件都满足才执行下一步
	0&& 0=0
	0&& 1=1
	1 && 0=1
	1 && 1=1
# 例子
	[1 -eq1]&&[2 -gt 1] && echo "执行正确"
	1=1并且2>1，打印”执行正确”
	[1 -eq1]&&[2 -It 1] && echo "执行正确"
	1=1并且2不小于1,不打印"执行正确”
	[1 -eq1 -a2 -ne 1]&& echo "执行正确”
	|/-o逻辑或:或者的意思,两边的条件只要有一个满足就执行下一步
	0||0=0
	0||0=0
	1||0=0
	1||1=1
	[1 -eq 1]||[2 -lt 1]&& echo "执行正确"
	[1 -eq 1 -o 2 -lt 1]&& echo "执行正确"
	1=1或者2小于1,打印”执行正确”
# !逻辑否(非),!写在[ ]里外都可以
取反的意思,满足前提条件,则不执行下一步，不满足前提条件执行下一步操作
	[1 -eq 1 ];echo $?
	![1 -eq 1 ];echo $?
	[!1 -eq 1 ];echo $?
```

#### 五、shell if语句类型

```bash
# 单分支
	if [条件测试语句]
	then
		命令序列
	fi
# 双分支
	if [条件测试语句]
	then
		命令序列1
	else
		命令序列2
	fi
# 多分支
	if [条件测试语句1 ]
	then
		命令序列1
	elif [条件测试语句2 ]
	then
		命令序列2
	else
		命令序列3
	fi
```

#### 六、shell for语句类型

```bash
for 变量名 in 取值列表
do
	命令序列(循环体)
done
例子
	打印1到10
	for i in seq `1 10`
	do
		echo $i
	done
# 批量创建以test开头的用,创建10个，初始密码设置123456
	for i in test{1..10}
	do
		useradd $i
		echo "123456"lpasswd --stdin $i &> /dev/nul
	done
# 根据文件批量检测多台主机的存活状态
	IP= $(cat /root/ip.txt)
	for i in $IP
	do
		ping -c2 -i0.2 -W3 $i &> /dev/null
	if[$? -eq 0 ]
	then
		echo "Host $i is up"
	else
		echo "Host $i is down"
	fi
	done
# 查看多台主机的多个端口是否开启(前提主机之间秘钥互信)
	for in 128 129
	do
		for p in 222325
		do
		ssh 192.168.80.$i netstat -anptu|grep -q "$p" && echo "port $p is up"
		done
	done
```

#### 七、shell while语句类型

```bash
while [条件表达式]
do
	命令序列
done
# 特殊的条件测试
true 真条件永远成立,无限循环,除非强制终止。
	while true.
	do.
		echo”123”。
	done。
# 例子
计算1到100的和
	a= 1
	sum=0
	while [ $a -le 100 ]
	do
		sum=' expr $sum + $a^
		a='expr$a+1
	done
	echo $sum
```

#### 八、shell case语句类型

```bash
case 变量值 in
模式1)
	命令序列 1
;;
模式2)
	命令序列 2
;;
*)
	默认命令序列
;;
esac
# 例子
提示用户输入一个字符判断出该字符是字母,数字或者其他字符
	read -p "输入一个字符” key
	case $key in
	[a-z][A-Z])
	echo "字母"
	;;
	[0-9])
	echo "数字”
	;;
	*)
	echo "其他字符"
	esac
sleep 1 控制脚本的循环速度(睡眠1s)
seq 起始值 步长 结束值
shell 循环控制结构
break 语句可以结束while,for,until或者select等结构的执行,退出循环体
continue 跳出本次循环,回到循环的开始位置,继续执行下次循环。
exit 退出脚本，循环体外的命令不会执行。
```

